### 关于脚手架
- 熟悉yargs脚手架开发框架
- 熟悉多packages管理工具的使用方法和实现原理
- 深入了解NodeJs模块路径解析流程

### 问答

#### yargs
- 脚手架构成
  - bin：package.json中配置bin属性，npm link本地安装
  - command：命令
  - options：参数
  - 文件顶部添加node环境 `#!/usr/bin/env node` 环境变量查询node环境使用node环境

- 脚手架初始化流程
  - 构造函数 `yargs()`
  - 常用方法 `cli.strict();cli.alias();cli.options()`

- 参数解析方法
  - `hideBin(process.argv)` / `yargs.argv`
  - `yargs.parse(argv,options)`

- 命令注册方法
  - `yargs.command(command,describe,builder,handler)`
  - `yargs.command({command,describe,builder,handler})`

#### lerna
- 基于 git + npm 的多package项目管理工具
- 实现原理
  - 通过`import-local`优先调用本地lerna命令
  - 通过`yargs`生成脚手架，先注册全局属性，再注册命令，最后通过parse方法解析参数
  - lerna注册命令时需要传入builder和handler两个方法，builder用于注册命令专属的options,handler用来处理命令的业务逻辑
  - lerna通过配置npm本地依赖的方式来进行本地开发，具体写法实在`package.json`的依赖中写入`file:your-local-module-path`，在lerna publish时会自动将该路径替换

#### Node.js 模块路径解析流程
- Node.js项目模块路径解析是通过`require.resolve`方法实现的
- `require.resolve`就是通过`Module._resolveFileName`方法实现的
- `require.resolve`实现原理
  - `Module._resolveFileName`方法的核心流程有3点：
    - 判断是否为内置模块
    - 通过 `Module._resolveLookUpPaths` 方法生成 `node_modules`可能存在的路径
    - 通过 `Module._finishPath` 查询模块的真实路径
  - `Module._findPath` 核心流程有4点
    - 查询缓存 （将`request`和`path`通过`\x00`合并成`cacheKey`）
    - 遍历`paths`，将`path`和`request`组成文件路径`basePath`
    - 如果`basePath`存在则调用`fs.realPathSync`获取文件真实路径
    - 将文件真实路径缓存到`Module._pathCache`(key就是前面生成的`cacheKey`)
  - `fs.realPathSync`的核心流程有3点：
    - 查询缓存（缓存的key为p,即`Module._finishPath`中生成的文件路径）
    - 从左往右遍历路径字符串，查询到`/`时拆分链接，判断该路径是否是软连接， 是软连接则查询真实链接，生成新路径，继续向后遍历
    - 遍历完成得到模块对应的真实路径，以原始路径作为`key`，真实路径作为`value`保存到缓存
- `require.resolve.paths`等价于`Module._resolveLookUpPaths`，该方法用于获得所有`node_modules`可能存在的路径
- `require.resolve.paths`实现原理
  - 如果路径为`/`（根目录），直接返回`['/node_modules']`
  - 否则，将路径字符串从后往前遍历，查询到`/`时，拆分路径，在后面加上`node_modules`，并传入一个`paths`数组，直至查询不到`/`后返回`paths`数组