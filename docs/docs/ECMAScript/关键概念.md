# 关键概念

## 单线程
- 为什么js是单线程的?
反推，如果是多线程的，同一时间分别进行dom的修改和移除，就会增加复杂性，所以js是单线程的，减少了这类复杂性

- web worker 使js变成多线程
但依然限制dom操作，避免这类复杂性

## `this`
指代当前代码运行时的上下文
1. 箭头函数：继承作用域链上一层上下文
2. `new`调用函数：指向new出来的对象
3. `call/bind/apply`：指向绑定的对象
    - `apply、call`的实现原理
        在传入的函数上创建一个临时方法，传入剩余参数调用此方法，最后删除临时创建的方法
    - `bind`的实现原理
        返回一个新函数，包裹了`apply、call`类似的处理方式
4. 全局函数：指向`window`
5. 对象上的函数，指向调用此函数的对象

## 闭包
#### 什么是作用域？
ES5 中只存在两种作用域：**全局作用域**和**函数作用域**。在 JavaScript 中，我们**将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称进行变量（变量名或者函数名）查找**

#### 什么是作用域链？
- 当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止
- 作用域链，就是有**当前作用域与上层作用域的一系列变量对象**组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。

#### 闭包产生的本质
当前环境中存在指向父级作用域的引用

#### 什么是闭包
闭包是一种特殊的对象，它由两部分组成：执行上下文（代号 A），以及在该执行上下文中创建的函数 （代号 B），当 B 执行时，如果访问了 A 中变量对象的值，那么闭包就会产生，且在 Chrome 中使用这个执行上下文 A 的函数名代指闭包。

#### 闭包是怎么产生的
函数中返回函数，内部函数有对外部函数的变量引用。

## AST抽象语法树
- 词法分析：`scanner`
    1. 读取代码，按照规则把他们变成一个个标识tokens,遇到空格，操作符，或者特殊符号的时候，它会认为一个token已经完成l 
    2. 移除空白符，注释
    3. 最后代码变成一个token列表
- 语法分析：解析器
    它会将词法分析出来的数组转化成树形的表达形式
    - 同时验证语法，语法有错误的话则抛出错误
    - 生成树的时候，解析器会删除一些没必要的标识tokens（比如不完整的括号）

## `var` `let` `const` 的区别
`var` 和 `let` `const` 的主要区别
1. 声明过程的不一样
    - 遇到有`var`的作用域，在任何语句执行前都已经完成了声明和初始化
    - `let` 和 `const` 先完成声明，并没有到初始化，提前访问会报错（**暂时性死区**）
2. `let` `const` **不允许重复声明**，var可以。
3. `let` `const` 在作用域之外不可使用，var可以。**块级作用域**
4. `const` 不允许修改，若是引用类型表示不允许修改这个指向。