# `HTTPS`

## 什么是`HTTPS`
`HTTPS = HTTP + SSL`

`HTTP`是应用层的协议，`HTTP`是直接和`TCP`通信的，当我们更换为`HTTPS`的时候，它就演变成了，先和`SSL`通信、然后再由`SSL`和`TCP`通信了

## 为什么用 `HTTPS`
- 和服务器通信时，直接采用明文传输，那么明文内容有可能被挟持监听和篡改
- 和服务器通信时，无法验证身份

## `HTTPS`如何实现加密（SSL过程）

### 了解两种加密方式
- 对称加密：同一把密钥既可以加密，也可以解密
- 非对称加密：**公钥**加密**私钥**解密，反之亦然

### 使用哪种加密方式？

- 单独使用对称加密：
服务器发送给浏览器的密钥依然容易被劫持：**既可以加密数据也可以解密数**

- 单独使用非对称加密：
服务器发送给浏览器的密钥依然容易被劫持：**可以解密服务器返回的数据**

- 使用两对非对称加密：
浏览器和服务器都要保存密钥，加密次数过多，**非常耗时**

- 使用非对称加密 + 对称加密 （`HTTPS`的实现）
服务器保存一对非对称密钥：公钥`A+`，私钥`A-`
    1. 客户端请求，服务器返回 `A+`
    2. 客户端利用`A+`对浏览器生成的对称密钥`B`加密，发送给服务器
    3. 服务端利用`A-`对发送过来的数据解密，获得`B`
    4. 之后的通信使用对称密钥`B`

## 还有什么问题？

#### 中间人劫持：
中间人保存一对非对称密钥：公钥`C+`，私钥`C-`
1. 中间人劫持服务器返回的公钥`A+`
2. 中间人发送自己的公钥`C+`给浏览器
3. 浏览器使用`C+`加密对称密钥`B`，发送给服务器
4. 中间人劫持浏览器，使用`C-`解密浏览器的数据获得`B`，再使用`A+`对`B`加密，发送给服务端
5. 服务器收到中间人发送的数据，使用`A-`解密获得`B`

接下来服务器和浏览器的通信都会被中间人劫持到，因为它得到了对称密钥B。

#### 解决中间人劫持：数字证书
被劫持的原因在于浏览器不能识别密钥是否是服务器的。向**CA机构**申请**数字证书**给服务器颁发**身份证**。

##### 数字签名
CA机构有一套非对称加密的 公钥`A+` 和 私钥`A-`
1. 网站向CA机构申请颁发数字证书；
2. CA机构通过审核之后，会生成一份**证书数据**（此时为明文，内容包括：书持有者信息、网站公钥、和有效期等）；
3. 利用散列函数对证书的明文数据进行Hash处理，生成一份**数据摘要**；
4. 接着利用私钥`A-`对这份数据摘要进行加密，得到**数字签名**；
5. 将证书**明文数据 + 数字签名** 合并到一起，组成完整的数字证书;
6. 将这份数字证书颁发给对应的网站。

##### 如何实现不被中间人攻击
关键：我们的浏览器已经预存了CA机构的**公钥**，中间人劫持不到。
1. 服务器返回数字证书（包括明文数据和数字签名）
2. 客户端接收到数字证书，对比**两份摘要**是否相同：
    - 第一份摘要：使用数字证书携带的hash算法对明文数据hash获得摘要
    - 第二份摘要：使用自带的公钥对数字签名解密获得摘要
3. 无论中间人怎么修改都会导致两份摘要不一样

## `HTTPS`完整的工作流程
前提：
- CA机构有一套非对称加密的公钥`A+` 和私钥`A-`，浏览器预存公钥`A+`
- 服务器也有一套非对称加密的公钥`B+` 和私钥`B-`

1. 浏览器向服务器发起请求；

2. 目标服务器收到请求，将**数字证书**返回给浏览器（包括公钥`B+`和**数字签名**）；

3. 浏览器收到证书之后，使用公钥`A+`解密**数字签名**得到**数据摘要T**，使用证书携带的`HASH`算法对数字证书上的**明文数据**计算得到**数据摘要S**，若 `T` = `S`，则证书有效

4. 使用服务器发送过来的公钥`B+`对随机生成的对称密钥`B`加密，发送给服务端

5. 服务端使用私钥`B-`对客户端发送的数据解密得到`B`，此时双方拥有了对称密钥`B`，此后的通信使用`B`加密解密