# 相关概念和原理

## 响应式原理
vue.js采用发布-订阅模式，使用`object.definedProperty()`劫持对象的`getter`，`setter`属性，在数据发生变化时，发布消息给订阅者，触发响应回调
#### `Object.defineProperty`的问题
- 检测数组
  - `Object.defineProperty`具有一定检测数组数据变化的能力，但是框架作者出于性能的考虑，放弃了这项特性
  - 数组只能使用经过hack过的方法触发数据的响应
- 该方法只能劫持数据的属性，需要通过递归，遍历等方式劫持每一个对象属性
- 相对于劫持每一个属性，劫持整个对象为更好的办法：Proxy

## 虚拟DOM
用对象来描述dom元素，修改数据属性时，使用虚拟dom对比，只修改有差异的部分，提高效率

## `computed`与`watch`的区别
#### 特点
- `computed`依赖属性，且会缓存，只有依赖的变量变化时才会重新计算
- `watch`观察属性，属性每次变化都会触发执行
#### 使用场景
- 在依赖数据变化来进行计算时使用`computed`，利用`computed`的缓存特性避免多次计算
- 在需要异步操作和持续观察数据时使用`watch`

## `key`的作用
- 不使用key的话，vue会就地复用元素，简单列表页可能更快，但是复用会带来 状态错位 ，不能触发过渡bug
- 使用key
  - 更精确：使用key来判断渲染元素，保证了元素的准确性
  - 更快速：key作为唯一标识能让框架更快速的查找

## `data`为什么必须是函数
- 组件是可以复用的，因为引用类型的关系，所有的组件将将会指向同一个`data`，数据将会污染
- 使用函数可以为每一个组件返回一个全新的`data`数据

## `nextTick`的原理
- vue中将数据中的变化进行统一，使用微任务到宏任务的降级方式在下一次执行栈执行之前进行渲染
  - `Promise => MutationObserver => setTimeout`
	- `microtask` 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕


## `keep-alive`的原理
1. 获取所包裹的组件对象和组件名
2. 根据`include/exclude`决定是否缓存，不缓存则直接返回子组件
3. 根据生成的key查找`keys`数组中是否已缓存组件，如已缓存则取出并更新该key在`keys`数组中的位置
4. 在`this.cache`中缓存该组件并设置key值，根据`LRU`规则，超过`max`的组件将会被删除
5. 然后将属性`keepAlive`设置为true，子组件的钩子将会用到

## `$set`有什么用
- data数据在初始化时会递归循环设置劫持，但是新增的属性直接赋值不会被劫持到
- 使用该方式会判断目标属性是否需要响应式然后进行响应式赋值处理

## `scoped`的作用
使样式只作用于当前组件
#### 原理
postcss给每个dom元素添加唯一id，给css选择器绑定此id与元素对应起来
#### 兼容：想要影响子组件的样式
- `/deep/` 关键字样式穿透
- 使用两个`style`标签，一个添加`scoped`，一个不添加
